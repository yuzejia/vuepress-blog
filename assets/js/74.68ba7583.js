(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{440:function(_,v,a){"use strict";a.r(v);var e=a(0),l=Object(e.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"记录-webpack-面试知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录-webpack-面试知识点"}},[_._v("#")]),_._v(" 记录 webpack 面试知识点")]),_._v(" "),a("h3",{attrs:{id:"webpack的构建流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack的构建流程"}},[_._v("#")]),_._v(" webpack的构建流程?")]),_._v(" "),a("p",[_._v("Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：")]),_._v(" "),a("ol",[a("li",[a("strong",[_._v("初始化参数")]),_._v("：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数；")]),_._v(" "),a("li",[a("strong",[_._v("开始编译")]),_._v("：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译；")]),_._v(" "),a("li",[a("strong",[_._v("确定⼊⼝")]),_._v("：根据配置中的 entry 找出所有的⼊⼝⽂件；")]),_._v(" "),a("li",[a("strong",[_._v("编译模块")]),_._v("：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；")]),_._v(" "),a("li",[a("strong",[_._v("完成模块编译")]),_._v("：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")]),_._v(" "),a("li",[a("strong",[_._v("输出资源")]),_._v("：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；")]),_._v(" "),a("li",[a("strong",[_._v("输出完成")]),_._v("：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。")])]),_._v(" "),a("p",[_._v("在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，"),a("strong",[_._v("插件")]),_._v("在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。")]),_._v(" "),a("h3",{attrs:{id:"_1-webpack与grunt、gulp的不同？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack与grunt、gulp的不同？"}},[_._v("#")]),_._v(" 1. "),a("strong",[_._v("webpack")]),_._v("与"),a("strong",[_._v("grunt")]),_._v("、"),a("strong",[_._v("gulp")]),_._v("的不同？")]),_._v(" "),a("p",[a("strong",[_._v("Grunt")]),_._v("**、Gulp是基于任务运⾏的⼯具**： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。")]),_._v(" "),a("p",[a("strong",[_._v("Webpack是基于模块化打包的⼯具:")]),_._v(" ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。")]),_._v(" "),a("p",[_._v("因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npm script代替Grunt、Gulp，npm script同样可以打造任务流。")]),_._v(" "),a("h3",{attrs:{id:"_2-webpack、rollup、parcel优劣？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-webpack、rollup、parcel优劣？"}},[_._v("#")]),_._v(" 2. "),a("strong",[_._v("webpack")]),_._v("、"),a("strong",[_._v("rollup")]),_._v("、"),a("strong",[_._v("parcel")]),_._v("优劣？")]),_._v(" "),a("ul",[a("li",[_._v("webpack适⽤于⼤型复杂的前端站点构建: webpack有强⼤的loader和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。")]),_._v(" "),a("li",[_._v("rollup适⽤于基础库的打包，如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。")]),_._v(" "),a("li",[_._v("parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。")])]),_._v(" "),a("h3",{attrs:{id:"_3-有哪些常⻅的loader？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-有哪些常⻅的loader？"}},[_._v("#")]),_._v(" 3. 有哪些常⻅的"),a("strong",[_._v("Loader")]),_._v("？")]),_._v(" "),a("ul",[a("li",[_._v("file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件")]),_._v(" "),a("li",[_._v("url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去")]),_._v(" "),a("li",[_._v("source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试")]),_._v(" "),a("li",[_._v("image-loader：加载并且压缩图⽚⽂件")]),_._v(" "),a("li",[_._v("babel-loader：把 ES6 转换成 ES5")]),_._v(" "),a("li",[_._v("css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性")]),_._v(" "),a("li",[_._v("style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。")]),_._v(" "),a("li",[_._v("eslint-loader：通过 ESLint 检查 JavaScript 代码")])]),_._v(" "),a("h3",{attrs:{id:"_4-有哪些常⻅的plugin？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-有哪些常⻅的plugin？"}},[_._v("#")]),_._v(" 4. 有哪些常⻅的"),a("strong",[_._v("Plugin")]),_._v("？")]),_._v(" "),a("ul",[a("li",[_._v("define-plugin：定义环境变量")]),_._v(" "),a("li",[_._v("html-webpack-plugin：简化html⽂件创建")]),_._v(" "),a("li",[_._v("uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码")]),_._v(" "),a("li",[_._v("webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度")]),_._v(" "),a("li",[_._v("webpack-bundle-analyzer: 可视化webpack输出⽂件的体积")]),_._v(" "),a("li",[_._v("mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载")])]),_._v(" "),a("h3",{attrs:{id:"_5-bundle，chunk，module是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-bundle，chunk，module是什么？"}},[_._v("#")]),_._v(" 5. "),a("strong",[_._v("bundle")]),_._v("，"),a("strong",[_._v("chunk")]),_._v("，"),a("strong",[_._v("module")]),_._v("是什么？")]),_._v(" "),a("ul",[a("li",[_._v("bundle：是由webpack打包出来的⽂件；")]),_._v(" "),a("li",[_._v("chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；")]),_._v(" "),a("li",[_._v("module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。")])]),_._v(" "),a("h3",{attrs:{id:"_6-loader和plugin的不同？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-loader和plugin的不同？"}},[_._v("#")]),_._v(" 6. "),a("strong",[_._v("Loader")]),_._v("和"),a("strong",[_._v("Plugin")]),_._v("的不同？")]),_._v(" "),a("p",[a("strong",[_._v("不同的作⽤")]),_._v(":")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("Loader")]),_._v('直译为"加载器"。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。')]),_._v(" "),a("li",[a("strong",[_._v("Plugin")]),_._v('直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。')])]),_._v(" "),a("p",[a("strong",[_._v("不同的⽤法")]),_._v(":")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("Loader")]),_._v("在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）")]),_._v(" "),a("li",[a("strong",[_._v("Plugin")]),_._v("在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。")])])])}),[],!1,null,null,null);v.default=l.exports}}]);